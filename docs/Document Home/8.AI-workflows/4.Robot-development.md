import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Robot Development
<Tabs>  
<TabItem value="ROS2" label="ROS2">
Install `turtlesim`, `ros2`, and `rqt`.

## Background

Turtlesim is a lightweight simulator for learning ROS 2.
It illustrates what ROS 2 does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on.

The ros2 tool is how the user manages, introspects, and interacts with a ROS system.
It supports multiple commands that target different aspects of the system and its operation.
One might use it to start a node, set a parameter, listen to a topic, and many more.
The ros2 tool is part of the core ROS 2 installation.

rqt is a graphical user interface (GUI) tool for ROS 2.
Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS 2 elements.

This tutorial touches upon core ROS 2 concepts, like nodes, topics, and services.
All of these concepts will be elaborated on in later tutorials; for now, you will simply set up the tools and get a feel for them.

### 1 Install turtlesim

As always, start by sourcing your setup files in a new terminal, as described in the 

Install the turtlesim package for your ROS 2 distro:

:::tabs

:::tab item="Linux"

```console
$ sudo apt update
$ sudo apt install ros-{DISTRO}-turtlesim
```

:::tab item="macOS"

As long as the archive you installed ROS 2 from contains the `ros_tutorials` repository, you should already have turtlesim installed.

:::tab item="Windows"

As long as the archive you installed ROS 2 from contains the `ros_tutorials` repository, you should already have turtlesim installed.

:::

To check if the package is installed, run the following command, which should return a list of turtlesim's executables:

```console
$ ros2 pkg executables turtlesim
turtlesim draw_square
turtlesim mimic
turtlesim turtle_teleop_key
turtlesim turtlesim_node
```

### 2 Start turtlesim

To start turtlesim, enter the following command in your terminal:

```console
$ ros2 run turtlesim turtlesim_node
[INFO] [turtlesim]: Starting turtlesim with node name /turtlesim
[INFO] [turtlesim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
```

Under the command, you will see messages from the node.
There you can see the default turtle's name and the coordinates where it spawns.

The simulator window should appear, with a random turtle in the center.



### 3 Use turtlesim

Open a new terminal and source ROS 2 again.

Now you will run a new node to control the turtle in the first node:

```console
$ ros2 run turtlesim turtle_teleop_key
```

At this point you should have three windows open: a terminal running `turtlesim_node`, a terminal running `turtle_teleop_key` and the turtlesim window.
Arrange these windows so that you can see the turtlesim window, but also have the terminal running `turtle_teleop_key` active so that you can control the turtle in turtlesim.

:::note

Pressing an arrow key will only cause the turtle to move a short distance and then stop.
This is because, realistically, you wouldn't want a robot to continue carrying on an instruction if, for example, the operator lost the connection to the robot.

:::

You can see the nodes, and their associated topics, services, and actions, using the `list` subcommands of the respective commands:

```console
$ ros2 node list
$ ros2 topic list
$ ros2 service list
$ ros2 action list
```

You will learn more about these concepts in the coming tutorials.
Since the goal of this tutorial is only to get a general overview of turtlesim, you will use rqt to call some of the turtlesim services and interact with `turtlesim_node`.
</TabItem>

<TabItem value="QIRPSDK" label="QIRP SDK">

The QIR SDK provides various sample applications. You can use ROS2 to get the device CPU load, utilize AI capabilities for gesture detection, and perform robot simulation. The robotics sample applications fall into different categories:

Platform sample applications
Robotics sample applications
AI sample applications
By combining different samples, you can implement various functionalities.

[Prep Your Device](https://docs.qualcomm.com/bundle/publicresource/topics/80-90441-2/qrb-ros-system-monitor_3_1_3.html)


Add Your Videos (H.264 MP4)
```shell
scp &lt;file_name&gt; ubuntu@[DEVICE IP-ADDR]:/opt/
```
Set Up Display
```shell
export XDG_RUNTIME_DIR=/run/user/</span></span>(id -u ubuntu)/
export WAYLAND_DISPLAY=wayland-1
```
:::note
If Weston isnâ€™t auto-enabling,hereâ€™s the hack:  
Open **two SSH sessions** â€” one to wake up Weston, the other to launch your app.

**1. Fire up Weston (First Shell):**
```bash
export GBM_BACKEND=msm && export XDG_RUNTIME_DIR=/run/user/$(id -u ubuntu)/ && mkdir -p <span class="latex-inline"><span class="katex-error" title="ParseError: KaTeX parse error: Expected &#x27;EOF&#x27;, got &#x27;&amp;&#x27; at position 17: â€¦DG_RUNTIME_DIR &amp;Ì²&amp; weston --contâ€¦" style="color:#cc0000">XDG_RUNTIME_DIR &amp;&amp; weston --continue-without-input --idle-time=0
```
**2. Set the Wayland Display environment(Shell #2)
```bash
export XDG_RUNTIME_DIR=/run/user/</span></span>(id -u ubuntu)/ && export WAYLAND_DISPLAY=wayland-1
```
:::
Play Multiple Videos!
```shell
gst-concurrent-videoplay-composition -c 4 \
-i /opt/<file1>.mp4 \
-i /opt/<file2>.mp4 \
-i /opt/<file3>.mp4 \
-i /opt/<file4>.mp4
```
ðŸ›‘ Stop Playback  
		Ctrl + C
</TabItem>
</Tabs>


