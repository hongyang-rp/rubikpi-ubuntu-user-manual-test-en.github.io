"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4520],{25145:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/img_v3_02h3_f64471dd-11fb-46bd-ae8a-72fdf86cc65g-05587f56bfe89be7041aa84fd8324981.jpg"},26161:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Document Home/peripherals-and-interfaces/m.2-key-m-connector","title":"M.2 Key M connector","description":"RUBIK Pi 3 provides an M.2 slot for NVMe storage, which can be used to install a 2280 (22 x 80mm) SSD hard drive. The M.2 Key M slot supports PCIe Gen3 x 2 and can deliver an output of up to 3.3V 2A. The switch of the M.2 connector can be individually controlled.","source":"@site/docs/Document Home/2.peripherals-and-interfaces/11.m.2-key-m-connector.md","sourceDirName":"Document Home/2.peripherals-and-interfaces","slug":"/Document Home/peripherals-and-interfaces/m.2-key-m-connector","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/peripherals-and-interfaces/m.2-key-m-connector","draft":false,"unlisted":false,"editUrl":"https://github.com/hongyang-rp/rubikpi-ubuntu-user-manual-test-en.github.io/tree/main/docs/Document Home/2.peripherals-and-interfaces/11.m.2-key-m-connector.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"RTC battery connector","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/peripherals-and-interfaces/rtc-battery"},"next":{"title":"40-pin LS connector","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/peripherals-and-interfaces/1.40-pin-ls-connector"}}');var i=s(74848),c=s(28453);const r={},o="M.2 Key M connector",a={},l=[{value:"Verify the PCIe bus functionality",id:"verify-the-pcie-bus-functionality",level:2},{value:"PCIe power management",id:"pcie-power-management",level:2},{value:"PCIe L0 link states",id:"pcie-l0-link-states",level:3},{value:"PCIe device states",id:"pcie-device-states",level:3},{value:"PCIe debugging",id:"pcie-debugging",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"m2-key-m-connector",children:"M.2 Key M connector"})}),"\n",(0,i.jsx)(n.p,{children:"RUBIK Pi 3 provides an M.2 slot for NVMe storage, which can be used to install a 2280 (22 x 80mm) SSD hard drive. The M.2 Key M slot supports PCIe Gen3 x 2 and can deliver an output of up to 3.3V 2A. The switch of the M.2 connector can be individually controlled."}),"\n",(0,i.jsxs)(n.p,{children:["The M.2 Key M connector uses the PCIe1 bus of the QCS6490. The device path is: ",(0,i.jsx)(n.em,{children:"/sys/bus/pci/devices/0001:00:00.0"})]}),"\n",(0,i.jsx)(n.p,{children:"The M.2 Key M connector is connector 18 in the following figure:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:s(79304).A+"",width:"3109",height:"1361"})}),"\n",(0,i.jsx)(n.p,{children:"The M.2 Key M connector is compatible with the 2280 SSD, as shown in the following figures:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.img,{src:s(30922).A+"",width:"1000",height:"750"}),"\n",(0,i.jsx)(n.img,{src:s(25145).A+"",width:"1000",height:"750"})]}),"\n",(0,i.jsx)(n.h2,{id:"verify-the-pcie-bus-functionality",children:"Verify the PCIe bus functionality"}),"\n",(0,i.jsxs)(n.p,{children:["After connecting the 2280 form factor SSD, the device node generated is ",(0,i.jsx)(n.code,{children:"/dev/nvme*"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Use a command similar to the following to mount the SSD. Verify the PCIe bus interface by accessing the contents of the ",(0,i.jsx)(n.em,{children:"/opt"})," directory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo mount /dev/nvme0n1p1 /opt/\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pcie-power-management",children:"PCIe power management"}),"\n",(0,i.jsx)(n.p,{children:"PCIe defines two types of power management methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Software power management, which determines the power management features for each device and manages them individually."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Systems that do not require software intervention, such as Active State Power Management (ASPM)."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When no data packets are being transmitted on the PCIe link, the device puts the PCIe link into a low-power state."}),"\n",(0,i.jsx)(n.h3,{id:"pcie-l0-link-states",children:"PCIe L0 link states"}),"\n",(0,i.jsx)(n.p,{children:"PCIe power management defines the following L0 link states:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"L0: working state"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"L0s: ASPM state with low-resume latency (energy saving standby state)"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pcie-device-states",children:"PCIe device states"}),"\n",(0,i.jsx)(n.p,{children:"PCIe power management defines the following device states:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D0 (mandatory): The device is fully ON. There are two sub-states."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D0 (uninitialized): The function is in D0 (uninitialized) state when waiting for enumeration and configuration after exiting the reset state."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D0 (active)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function enters the D0 (active) state once the enumeration and configuration process is completed."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function enters the D0 (active) state when the system software enables one or more (in any combination) function parameters, such as memory space enable, I/O space enable, or BME bits."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D1 (optional): light sleep state"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function can only initiate the PME message and cannot initiate other TLPs."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function can only serve as the target for configuration transactions, not for other transactions."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function enters the D1 state via a software command that sets the PM control and status registers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D2 (optional): deep sleep state"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function can only issue PME messages and cannot issue other TLPs."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function can only serve as the target for configuration transactions, not for other transactions."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function enters the D2 state via software commands that set the PM control and status registers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D3 (mandatory): The device is in the lowest power state, and this function must support two types of D3 states:"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D3 (hot)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function can only issue PME messages and cannot issue other TLPs."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function can only serve as the target for configuration transactions, not for other transactions."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The function enters D3 (hot) state by issuing a software command that sets the power state field."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"D3(cold): The device enters the D3 (cold) state and is powered off. When power is restored, the device enters the D0 (uninitialized) state."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pcie-debugging",children:"PCIe debugging"}),"\n",(0,i.jsxs)(n.p,{children:["The M.2 Key M connector uses the PCIe1 bus of the QCS6490. The device path is: ",(0,i.jsx)(n.em,{children:"/sys/bus/pci/devices/0001:00:00.0"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"lspci"})," and ",(0,i.jsx)(n.code,{children:"setpci"})," commands are native to Linux distributions. These two commands provide multiple levels of output and can also be used to view the capabilities and states of different components trained on the PCI bus at a given time. Most of these capabilities reflect the configuration space registers required by the PCIe basic specification. For more detailed information, visit ",(0,i.jsx)(n.a,{href:"https://pcisig.com/specifications",children:"https://pcisig.com/specifications"}),". To view the usage instructions, run the following command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"lspci --help\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following features help in debugging PCIe issues:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Display device information."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"lspci\n"})}),"\n",(0,i.jsx)(n.p,{children:"Sample output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"0000:00:00.0 PCI bridge: Qualcomm Device 010b\n0000:01:00.0 USB controller: Renesas Technology Corp. uPD720201 USB 3.0 Host Controller (rev 03)\n0001:00:00.0 PCI bridge: Qualcomm Device 010b\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Show PCIe device and vendor IDs in the device control registers."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"lspci -nvmm\n"})}),"\n",(0,i.jsx)(n.p,{children:"Sample output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"Slot:        00:00.0\nClass:        0604\nVendor:        17cb\nDevice:        010b\nIOMMUGroup:        6\n\nSlot:        01:00.0\nClass:        0c03\nVendor:        1912\nDevice:        0014\nRev:        03\nProgIf:        30\nIOMMUGroup:        6\n\nSlot:        0001:00:00.0\nClass:        0604\nVendor:        17cb\nDevice:        010b\nDTNode:        /sys/firmware/devicetree/base/soc@0/pci@1c08000/pcie@1\nIOMMUGroup:        7\n\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(96540);const i={},c=t.createContext(i);function r(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(c.Provider,{value:n},e.children)}},30922:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/img_v3_02h3_2bbba98e-82ca-47ed-9b20-cf96deb8e13g-ed2375f85ca402baaec1c50fa146ae76.jpg"},79304:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/data-3-5347d00ec77bf852ac7f0c81660136ea.svg"}}]);