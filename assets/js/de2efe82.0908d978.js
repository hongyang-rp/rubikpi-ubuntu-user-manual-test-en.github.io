"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5508],{13564:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"Document Home/Application Development and Execution Guide/index","title":"Application Development and Execution Guide","description":"This guide walks through the full lifecycle of AI development using Qualcomm\xae-supported tools, runtimes, and frameworks.","source":"@site/docs/Document Home/2.Application Development and Execution Guide/index.md","sourceDirName":"Document Home/2.Application Development and Execution Guide","slug":"/Document Home/Application Development and Execution Guide/","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/Application Development and Execution Guide/","draft":false,"unlisted":false,"editUrl":"https://github.com/hongyang-rp/rubikpi-ubuntu-user-manual-test-en.github.io/tree/main/docs/Document Home/2.Application Development and Execution Guide/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Ubuntu Desktop Vs Server","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/ubuntu-desktop-vs-server"},"next":{"title":"Edge Impulse","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/Application Development and Execution Guide/Building AI Models/edge_impulse"}}');var o=i(62540),s=i(43023);const r={},l="Application Development and Execution Guide",u={},a=[{value:"\ud83d\udcca Application Development &amp; Execution Flow Summary",id:"-application-development--execution-flow-summary",level:2}];function d(e){const n={a:"a",br:"br",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"application-development-and-execution-guide",children:"Application Development and Execution Guide"})}),"\n",(0,o.jsxs)(n.p,{children:["This guide walks through the full lifecycle of AI development using Qualcomm\xae-supported tools, runtimes, and frameworks.",(0,o.jsx)(n.br,{}),"\n","Whether you're training models, deploying pre-trained networks, or building multimodal AI workflows, this guide offers a modular, hands-on approach.",(0,o.jsx)(n.br,{}),"\n","The document covers:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Model creation with ",(0,o.jsx)(n.strong,{children:"Edge Impulse"})," and ",(0,o.jsx)(n.strong,{children:"Qualcomm\xae AI Hub"})]}),"\n",(0,o.jsxs)(n.li,{children:["Inference using ",(0,o.jsx)(n.strong,{children:"LiteRT, TensorFlow Lite, and ONNX Runtime"})]}),"\n",(0,o.jsxs)(n.li,{children:["Local execution of large language models with ",(0,o.jsx)(n.strong,{children:"Llama.cpp"})]}),"\n",(0,o.jsxs)(n.li,{children:["Workflow orchestration with ",(0,o.jsx)(n.strong,{children:"Genie"})]}),"\n",(0,o.jsxs)(n.li,{children:["Sample applications using ",(0,o.jsx)(n.strong,{children:"IMSDK"})," and robotics SDKs"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Each section is designed to be standalone, so you can jump directly into the tools and flows that match your project needs. The goal is to provide clear, reusable examples and practical insights for integrating AI into real-world edge applications."}),"\n",(0,o.jsx)(n.h2,{id:"-application-development--execution-flow-summary",children:"\ud83d\udcca Application Development & Execution Flow Summary"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Flow"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.a,{href:"https://hongyang-rp.github.io/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document%20Home/Application%20Development%20and%20Execution%20Guide/Building%20AI%20Models/edge_impulse#train-an-ai-model",children:(0,o.jsx)(n.strong,{children:"Edge Impulse"})})}),(0,o.jsx)(n.td,{children:"Build and train AI models using audio, image and other sensor data - or bringing your own model in a variety of formats."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.a,{href:"https://hongyang-rp.github.io/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document%20Home/Application%20Development%20and%20Execution%20Guide/Building%20AI%20Models/qualcomm_ai_hub#finding-supported-models",children:(0,o.jsx)(n.strong,{children:"Qualcomm\xae AI Hub"})})}),(0,o.jsx)(n.td,{children:"Qualcomm\xae AI Hub simplifies deploying AI models for vision, audio, and speech applications to edge devices. You can optimize, validate, and deploy your own AI models on hosted Qualcomm platform devices within minutes."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.a,{href:"https://hongyang-rp.github.io/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document%20Home/Application%20Development%20and%20Execution%20Guide/Framework-Driven%20AI%20Sample%20Execution/litert_tflite#quantizing-models",children:(0,o.jsx)(n.strong,{children:"LiteRT/TFLite"})})}),(0,o.jsx)(n.td,{children:"LiteRT enables high-performance, on-device AI by running quantized models (Python or C++) on both CPU and NPU of Dragonwing devices using AI Engine Direct delegates\u2014all with minimal setup."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.a,{href:"https://hongyang-rp.github.io/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document%20Home/Application%20Development%20and%20Execution%20Guide/Framework-Driven%20AI%20Sample%20Execution/onnx#onnxruntime-wheel-with-ai-engine-direct",children:(0,o.jsx)(n.strong,{children:"ONNX"})})}),(0,o.jsx)(n.td,{children:"ONNX enables cross-platform AI deployment by exporting models. On Dragonwing devices, ONNX Runtime with AI Engine Direct allows execution on the NPU for maximum performance."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.a,{href:"https://hongyang-rp.github.io/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document%20Home/Application%20Development%20and%20Execution%20Guide/Framework-Driven%20AI%20Sample%20Execution/llama_cpp#builing-llamacpp",children:(0,o.jsx)(n.strong,{children:"Llama.cpp"})})}),(0,o.jsx)(n.td,{children:"Execute large language models locally using a C++ backend optimized for CPUs and quantized formats."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.a,{href:"https://hongyang-rp.github.io/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document%20Home/Application%20Development%20and%20Execution%20Guide/Framework-Driven%20AI%20Sample%20Execution/genie#installing-ai-runtime-sdk---community-edition",children:(0,o.jsx)(n.strong,{children:"Qualcomm\xae Genie"})})}),(0,o.jsx)(n.td,{children:"Orchestrate AI microservices and multimodal workflows using Qualcomm\u2019s generative AI runtime."})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},43023:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(63696);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);