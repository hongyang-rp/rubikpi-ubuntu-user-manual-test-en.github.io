"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8995],{5045:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Document Home/Application Development and Execution Guide/Building AI Models/qualcomm_ai_hub","title":"Qualcomm\xae AI Hub","description":"Qualcomm AI Hub contains a large collection of pretrained AI models that are optimized to run on Dragonwing hardware on the NPU.","source":"@site/docs/Document Home/3.Application Development and Execution Guide/1.Building AI Models/2.qualcomm_ai_hub.md","sourceDirName":"Document Home/3.Application Development and Execution Guide/1.Building AI Models","slug":"/Document Home/Application Development and Execution Guide/Building AI Models/qualcomm_ai_hub","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/Application Development and Execution Guide/Building AI Models/qualcomm_ai_hub","draft":false,"unlisted":false,"editUrl":"https://github.com/hongyang-rp/rubikpi-ubuntu-user-manual-test-en.github.io/tree/main/docs/Document Home/3.Application Development and Execution Guide/1.Building AI Models/2.qualcomm_ai_hub.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Edge Impulse","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/Application Development and Execution Guide/Building AI Models/edge_impulse"},"next":{"title":"LiteRT / TFLite","permalink":"/rubikpi-ubuntu-user-manual-test-en.github.io/docs/Document Home/Application Development and Execution Guide/Framework-Driven AI Sample Execution/litert_tflite"}}');var o=r(74848),i=r(28453);const a={},s="Qualcomm\xae AI Hub",l={},d=[{value:"Finding supported models",id:"finding-supported-models",level:2},{value:"Deploying a model to NPU (Python)",id:"deploying-a-model-to-npu-python",level:2},{value:"Running the example repository",id:"running-the-example-repository",level:3},{value:"Porting the model to NPU",id:"porting-the-model-to-npu",level:3},{value:"Preprocessing inputs",id:"preprocessing-inputs",level:4},{value:"Postprocessing outputs",id:"postprocessing-outputs",level:4},{value:"End-to-end example (Python)",id:"end-to-end-example-python",level:3},{value:"Deploying a model to NPU (Edge Impulse)",id:"deploying-a-model-to-npu-edge-impulse",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"qualcomm-ai-hub",children:"Qualcomm\xae AI Hub"})}),"\n",(0,o.jsxs)(n.p,{children:["Qualcomm ",(0,o.jsx)(n.a,{href:"https://aihub.qualcomm.com",children:"AI Hub"})," contains a large collection of pretrained AI models that are optimized to run on Dragonwing hardware on the NPU."]}),"\n",(0,o.jsx)(n.h2,{id:"finding-supported-models",children:"Finding supported models"}),"\n",(0,o.jsx)(n.p,{children:"Models in AI Hub are categorized by supported Qualcomm chipset. To see models that will run on your development kit:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Go to the ",(0,o.jsx)(n.a,{href:"https://aihub.qualcomm.com/iot/models",children:"model list"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Under 'Chipset', select:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"RB3 Gen 2 Vision Kit: 'Qualcomm QCS6490 (Proxy)'"}),"\n",(0,o.jsx)(n.li,{children:"RUBIK Pi 3: 'Qualcomm QCS6490 (Proxy)'"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"deploying-a-model-to-npu-python",children:"Deploying a model to NPU (Python)"}),"\n",(0,o.jsxs)(n.p,{children:["As an example, let's deploy the ",(0,o.jsx)(n.a,{href:"https://aihub.qualcomm.com/iot/models/face_det_lite",children:"Lightweight-Face-Detection"})," model."]}),"\n",(0,o.jsx)(n.h3,{id:"running-the-example-repository",children:"Running the example repository"}),"\n",(0,o.jsxs)(n.p,{children:["All AI Hub models come with an example repository. This is a good starting point, as it shows exactly how to ",(0,o.jsx)(n.em,{children:"run"})," the model. It shows what the input to your network should look like, and how to interpret the output (here, to map the output tensor to bounding boxes). The example repositories do ",(0,o.jsx)(n.em,{children:"NOT"})," run on the NPU or GPU yet - they run without acceleration. Let's see what our input/output should look like before we move this model to the NPU."]}),"\n",(0,o.jsxs)(n.p,{children:["On the AI Hub page for ",(0,o.jsx)(n.a,{href:"https://aihub.qualcomm.com/iot/models/face_det_lite",children:"Lightweight-Face-Detection"}),', click "Model repository". This links you to a ',(0,o.jsx)(n.a,{href:"https://github.com/quic/ai-hub-models/tree/main/qai_hub_models/models/facemap_3dmm",children:"README"})," file with instructions on how to run the example repository."]}),"\n",(0,o.jsx)(n.p,{children:"To deploy this model, open the terminal on your development board, or an ssh session to your development board, and:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Create a new venv and install some base packages:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"mkdir -p ~/aihub-demo\r\ncd ~/aihub-demo\r\n\r\npython3 -m venv .venv\r\nsource .venv/bin/activate\r\n\r\npip3 install numpy setuptools Cython shapely\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Download an image with a face (640x480 resolution, JPG format) onto your development board, e.g. via:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"wget https://cdn.edgeimpulse.com/qc-ai-docs/example-images/three-people-640-480.jpg\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://3580193864-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FxM5xrbdbelLSl7uN8oac%2Fuploads%2Fgit-blob-0cc3ca50bf1d29e11512b6bedb879ed101e8f7bb%2Faihub-three-people-in.jpg?",alt:"",title:"Input image with three people"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input resolution:"}),' AI Hub models require correctly sized inputs. You can find the required resolution under "Technical Details > Input resolution" (in ',(0,o.jsx)(n.em,{children:"HEIGHT x WIDTH"})," (here 480x640 => 640x480 for wxh)); or inspect the size of the input tensor on the TFLite or ONNX file."]})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Follow the instructions under 'Example & Usage' for the Facial Landmark Detection model:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'# Install the example (add --no-build-isolation)\r\npip3 install --no-build-isolation "qai-hub-models[face-det-lite]"\r\n\r\n# Run the example\r\n#    Use --help to see all options\r\npython3 -m qai_hub_models.models.face_det_lite.demo --quantize w8a8 --image ./three-people-640-480.jpg --output-dir out/\n'})}),"\n",(0,o.jsxs)(n.p,{children:["You can find the output image in ",(0,o.jsx)(n.code,{children:"out/FaceDetLitebNet_output.png"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"If you're connected over ssh, you can copy the output image back to your host computer via:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Find IP via: ifconfig | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1'\r\n# Then: (replace 192.168.1.148 by the IP address of your development kit)\r\n\r\nscp ubuntu@192.168.1.148:~/aihub-demo/out/FaceDetLitebNet_output.png ~/Downloads/FaceDetLitebNet_output.png\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://3580193864-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FxM5xrbdbelLSl7uN8oac%2Fuploads%2Fgit-blob-a7485166f25f0813e5ef1b94a8654353f644a8f7%2Faihub-three-people-annotated.png?alt=media",alt:"",title:"Lightweight face detection output"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Alright! We have a working model. For reference, on the RB3 Gen 2 Vision Kit, running this model takes 189.7ms per inference."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"porting-the-model-to-npu",children:"Porting the model to NPU"}),"\n",(0,o.jsx)(n.p,{children:"Now that we have a working reference model, let's run it on the NPU. There are three parts that you need to implement."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"You need to preprocess the data, e.g. convert the image into features that you can pass to the neural network."}),"\n",(0,o.jsxs)(n.li,{children:["You need to export the model to ONNX or TFLite, and run the model through ",(0,o.jsx)(n.a,{href:"https://qc-ai-test.gitbook.io/qc-ai-test-docs/running-building-ai-models/lite-rt",children:"LiteRT"})," or ",(0,o.jsx)(n.a,{href:"https://qc-ai-test.gitbook.io/qc-ai-test-docs/running-building-ai-models/onnxruntime",children:"ONNX Runtime"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"You need to postprocess the output, e.g. convert the output of the neural network to bounding boxes of faces."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The model is straight forward, as you can read in the ",(0,o.jsx)(n.a,{href:"https://qc-ai-test.gitbook.io/qc-ai-test-docs/running-building-ai-models/lite-rt",children:"LiteRT"})," and ",(0,o.jsx)(n.a,{href:"https://qc-ai-test.gitbook.io/qc-ai-test-docs/running-building-ai-models/onnxruntime",children:"ONNX Runtime"})," pages. However, the pre- and post-processing code might not be..."]}),"\n",(0,o.jsx)(n.h4,{id:"preprocessing-inputs",children:"Preprocessing inputs"}),"\n",(0,o.jsxs)(n.p,{children:["For image models most AI Hub models take a matrix of ",(0,o.jsx)(n.code,{children:"(HEIGHT, WIDTH, CHANNELS)"})," (LiteRT) or ",(0,o.jsx)(n.code,{children:"(CHANNELS, HEIGHT, WIDTH)"})," (ONNX) scaled from 0..1. If you have 1 channel, convert the image to grayscale first. If your model is quantized (most likely) you'll also need to read zero_point and scale, and scale the pixels accordingly (this is easy in LiteRT as they contain the quantization parameters, but ONNX does not have these). Typically you'll end up with data scaled linearly 0..255 (uint8) or -128..127 (int8) for quantized models - so that's relatively easy. A function that demonstrates all this in Python can be found below in the example code (",(0,o.jsx)(n.code,{children:"def load_image_litert"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"HOWEVER..."})," This is not guaranteed; and this is where the AI Hub example code comes in. Every AI Hub example contains the exact code used to scale inputs. In our current example - Lightweight-Face-Detection - the input is shaped ",(0,o.jsx)(n.code,{children:"(480, 640, 1)"}),". However, if you look at the ",(0,o.jsx)(n.a,{href:"https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/app.py#L70",children:"preprocessing code"})," the data is not converted to grayscale, but instead only the blue channel of an RGB image is taken:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'img_array = img_array.astype("float32") / 255.0\r\nimg_array = img_array[np.newaxis, ...]\r\nimg_tensor = torch.Tensor(img_array)\r\nimg_tensor = img_tensor[:, :, :, -1]        # HERE WE TAKE BLUE CHANNEL, NOT CONVERT TO GRAYSCALE\n'})}),"\n",(0,o.jsx)(n.p,{children:"These kind of things are very easy to get wrong. So if you see non-matching results between your implementation and the AI Hub example: read the code. This applies even more for non-image inputs (e.g. audio). Use the demo code to understand what the model actually expects."}),"\n",(0,o.jsx)(n.h4,{id:"postprocessing-outputs",children:"Postprocessing outputs"}),"\n",(0,o.jsxs)(n.p,{children:["The same applies to postprocessing. For example, there's no standard way of mapping the output of a neural network to bounding boxes (to detect faces). For Lightweight-Face-Detection you can find the code here: ",(0,o.jsx)(n.a,{href:"https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/app.py#L77",children:"face_det_lite/app.py#L77"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"If you're targeting Python, it's often easiest to copy the postprocessing code into your application; as AI Hub has a lot of dependencies that you might not want. In addition the postprocessing code operates on PyTorch tensors, and your inference runs under LiteRT or ONNX Runtime; thus, you'll need to change some small aspects. We'll show this just below in the end-to-end example."}),"\n",(0,o.jsx)(n.h3,{id:"end-to-end-example-python",children:"End-to-end example (Python)"}),"\n",(0,o.jsx)(n.p,{children:"With the explanation behind us, let's look at some code."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Open a terminal on your development board, and set up the base requirements for this example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Create a new fresh directory\r\nmkdir -p ~/aihub-npu\r\ncd ~/aihub-npu\r\n\r\n# Create a new venv\r\npython3 -m venv .venv\r\nsource .venv/bin/activate\r\n\r\n# Install the LiteRT runtime (to run models) and Pillow (to parse images)\r\npip3 install ai-edge-litert==1.3.0 Pillow\r\n\r\n# Download an example image\r\nwget https://cdn.edgeimpulse.com/qc-ai-docs/example-images/three-people-640-480.jpg\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The NPU only supports uint8/int8 quantized models. Fortunately AI Hub contains pre-quantized and optimized models already. You can either:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Download the model for this tutorial (mirrored on CDN):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"wget https://cdn.edgeimpulse.com/qc-ai-docs/models/face_det_lite-lightweight-face-detection-w8a8.tflite\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Or, for any other model - download the model from AI Hub and push to your development board:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Go to ",(0,o.jsx)(n.a,{href:"https://aihub.qualcomm.com/iot/models/face_det_lite",children:"Lightweight-Face-Detection"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:'Click "Download model".'}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:'Select "TFLite" for runtime, and "w8a8" for precision.'}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://3580193864-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FxM5xrbdbelLSl7uN8oac%2Fuploads%2Fgit-blob-a402e668a1082b6c0fc8dfdbe2cec20f204dee2d%2Faihub-download.png?alt=media",alt:"",title:"Downloading w8a8 quantized model from AI Hub in TFLite format"})}),"\n",(0,o.jsxs)(n.p,{children:["If your model is only available in ONNX format, see ",(0,o.jsx)(n.a,{href:"https://qc-ai-test.gitbook.io/qc-ai-test-docs/running-building-ai-models/onnxruntime",children:"Run models using ONNX Runtime"})," for instructions. The same principles as in this tutorial apply."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Download the model."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"If you're not downloading the model directly on your Dragonwing development board, you'll need to push the model over ssh:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Find the IP address of your development board. Run on your development board:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ifconfig | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1'\r\n\r\n# ... Example:\r\n# 192.168.1.253\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Push the .tflite file. Run from your computer:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"scp face_det_lite-lightweight-face-detection-w8a8.tflite ubuntu@192.168.1.253:~/face_det_lite-lightweight-face-detection-w8a8.tflite\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Create a new file ",(0,o.jsx)(n.code,{children:"face_detection.py"}),". This file contains the model invocation, plus the preprocessing and postprocessing code from the AI Hub example (see inline comments)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\nfrom ai_edge_litert.interpreter import Interpreter, load_delegate\r\nfrom PIL import Image, ImageDraw\r\nimport os, time, sys\r\n\r\ndef curr_ms():\r\n    return round(time.time() * 1000)\r\n\r\n# Paths\r\nIMAGE_IN = \'three-people-640-480.jpg\'\r\nIMAGE_OUT = \'three-people-640-480-overlay.jpg\'\r\nMODEL_PATH = \'face_det_lite-lightweight-face-detection-w8a8.tflite\'\r\n\r\n# If we pass in --use-qnn we offload to NPU\r\nuse_qnn = True if len(sys.argv) >= 2 and sys.argv[1] == \'--use-qnn\' else False\r\n\r\nexperimental_delegates = []\r\nif use_qnn:\r\n    experimental_delegates = [load_delegate("libQnnTFLiteDelegate.so", options={"backend_type":"htp"})]\r\n\r\n# Load TFLite model and allocate tensors\r\ninterpreter = Interpreter(\r\n    model_path=MODEL_PATH,\r\n    experimental_delegates=experimental_delegates\r\n)\r\ninterpreter.allocate_tensors()\r\n\r\n# Get input and output tensor details\r\ninput_details = interpreter.get_input_details()\r\noutput_details = interpreter.get_output_details()\r\n\r\n# === BEGIN PREPROCESSING ===\r\n\r\n# Load an image (using Pillow) and make it in the right format that the interpreter expects (e.g. quantize)\r\n# All AI Hub image models use 0..1 inputs to start.\r\ndef load_image_litert(interpreter, path, single_channel_behavior: str = \'grayscale\'):\r\n    d = interpreter.get_input_details()[0]\r\n    shape = [int(x) for x in d["shape"]]  # e.g. [1, H, W, C] or [1, C, H, W]\r\n    dtype = d["dtype"]\r\n    scale, zp = d.get("quantization", (0.0, 0))\r\n\r\n    if len(shape) != 4 or shape[0] != 1:\r\n        raise ValueError(f"Unexpected input shape: {shape}")\r\n\r\n    # Detect layout\r\n    if shape[1] in (1, 3):   # [1, C, H, W]\r\n        layout, C, H, W = "NCHW", shape[1], shape[2], shape[3]\r\n    elif shape[3] in (1, 3): # [1, H, W, C]\r\n        layout, C, H, W = "NHWC", shape[3], shape[1], shape[2]\r\n    else:\r\n        raise ValueError(f"Cannot infer layout from shape {shape}")\r\n\r\n    # Load & resize\r\n    img = Image.open(path).convert("RGB").resize((W, H), Image.BILINEAR)\r\n    arr = np.array(img)\r\n    if C == 1:\r\n        if single_channel_behavior == \'grayscale\':\r\n            # Convert to luminance (H, W)\r\n            gray = np.asarray(Image.fromarray(arr).convert(\'L\'))\r\n        elif single_channel_behavior in (\'red\', \'green\', \'blue\'):\r\n            ch_idx = {\'red\': 0, \'green\': 1, \'blue\': 2}[single_channel_behavior]\r\n            gray = arr[:, :, ch_idx]\r\n        else:\r\n            raise ValueError(f"Invalid single_channel_behavior: {single_channel_behavior}")\r\n        # Keep shape as HWC with C=1\r\n        arr = gray[..., np.newaxis]\r\n\r\n    # HWC -> correct layout\r\n    if layout == "NCHW":\r\n        arr = np.transpose(arr, (2, 0, 1))  # (C,H,W)\r\n\r\n    # Scale 0..1 (all AI Hub image models use this)\r\n    arr = (arr / 255.0).astype(np.float32)\r\n\r\n    # Quantize if needed\r\n    if scale and float(scale) != 0.0:\r\n        q = np.rint(arr / float(scale) + int(zp))\r\n        if dtype == np.uint8:\r\n            arr = np.clip(q, 0, 255).astype(np.uint8)\r\n        else:\r\n            arr = np.clip(q, -128, 127).astype(np.int8)\r\n\r\n    return np.expand_dims(arr, 0)  # add batch\r\n\r\n# This model looks like grayscale, but AI Hub inference actually takes the BLUE channel\r\n# see https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/app.py#L70\r\ninput_data = load_image_litert(interpreter, IMAGE_IN, single_channel_behavior=\'blue\')\r\n\r\n# === END PREPROCESSING (input_data contains right data) ===\r\n\r\n# Set tensor and run inference\r\ninterpreter.set_tensor(input_details[0][\'index\'], input_data)\r\n\r\n# Run once to warmup\r\ninterpreter.invoke()\r\n\r\n# Then run 10x\r\nstart = curr_ms()\r\nfor i in range(0, 10):\r\n    interpreter.invoke()\r\nend = curr_ms()\r\n\r\n# === BEGIN POSTPROCESSING ===\r\n\r\n# Grab 3 output tensors and dequantize\r\nq_output_0 = interpreter.get_tensor(output_details[0][\'index\'])\r\nscale_0, zero_point_0 = output_details[0][\'quantization\']\r\nhm = ((q_output_0.astype(np.float32) - zero_point_0) * scale_0)[0]\r\n\r\nq_output_1 = interpreter.get_tensor(output_details[1][\'index\'])\r\nscale_1, zero_point_1 = output_details[1][\'quantization\']\r\nbox = ((q_output_1.astype(np.float32) - zero_point_1) * scale_1)[0]\r\n\r\nq_output_2 = interpreter.get_tensor(output_details[2][\'index\'])\r\nscale_2, zero_point_2 = output_details[2][\'quantization\']\r\nlandmark = ((q_output_2.astype(np.float32) - zero_point_2) * scale_2)[0]\r\n\r\n# Taken from https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/utils/bounding_box_processing.py#L369\r\ndef get_iou(boxA: np.ndarray, boxB: np.ndarray) -> float:\r\n    """\r\n    Given two tensors of shape (4,) in xyxy format,\r\n    compute the iou between the two boxes.\r\n    """\r\n    xA = max(boxA[0], boxB[0])\r\n    yA = max(boxA[1], boxB[1])\r\n    xB = min(boxA[2], boxB[2])\r\n    yB = min(boxA[3], boxB[3])\r\n\r\n    inter_area = max(0, xB - xA + 1) * max(0, yB - yA + 1)\r\n    boxA_area = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)\r\n    boxB_area = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)\r\n\r\n    return inter_area / float(boxA_area + boxB_area - inter_area)\r\n\r\n# Taken from https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/utils.py\r\nclass BBox:\r\n    # Bounding Box\r\n    def __init__(\r\n        self,\r\n        label: str,\r\n        xyrb: list[int],\r\n        score: float = 0,\r\n        landmark: list | None = None,\r\n        rotate: bool = False,\r\n    ):\r\n        """\r\n        A bounding box plus landmarks structure to hold the hierarchical result.\r\n        parameters:\r\n            label:str the class label\r\n            xyrb: 4 list for bbox left, top,  right bottom coordinates\r\n            score:the score of the detection\r\n            landmark: 10x2 the landmark of the joints [[x1,y1], [x2,y2]...]\r\n        """\r\n        self.label = label\r\n        self.score = score\r\n        self.landmark = landmark\r\n        self.x, self.y, self.r, self.b = xyrb\r\n        self.rotate = rotate\r\n\r\n        minx = min(self.x, self.r)\r\n        maxx = max(self.x, self.r)\r\n        miny = min(self.y, self.b)\r\n        maxy = max(self.y, self.b)\r\n        self.x, self.y, self.r, self.b = minx, miny, maxx, maxy\r\n\r\n    @property\r\n    def width(self) -> int:\r\n        return self.r - self.x + 1\r\n\r\n    @property\r\n    def height(self) -> int:\r\n        return self.b - self.y + 1\r\n\r\n    @property\r\n    def box(self) -> list[int]:\r\n        return [self.x, self.y, self.r, self.b]\r\n\r\n    @box.setter\r\n    def box(self, newvalue: list[int]) -> None:\r\n        self.x, self.y, self.r, self.b = newvalue\r\n\r\n    @property\r\n    def haslandmark(self) -> bool:\r\n        return self.landmark is not None\r\n\r\n    @property\r\n    def xywh(self) -> list[int]:\r\n        return [self.x, self.y, self.width, self.height]\r\n\r\n# Taken from https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/utils.py\r\ndef nms(objs: list[BBox], iou: float = 0.5) -> list[BBox]:\r\n    """\r\n    nms function customized to work on the BBox objects list.\r\n    parameter:\r\n        objs: the list of the BBox objects.\r\n    return:\r\n        the rest of the BBox after nms operation.\r\n    """\r\n    if objs is None or len(objs) <= 1:\r\n        return objs\r\n\r\n    objs = sorted(objs, key=lambda obj: obj.score, reverse=True)\r\n    keep = []\r\n    flags = [0] * len(objs)\r\n    for index, obj in enumerate(objs):\r\n        if flags[index] != 0:\r\n            continue\r\n\r\n        keep.append(obj)\r\n        for j in range(index + 1, len(objs)):\r\n            # if flags[j] == 0 and obj.iou(objs[j]) > iou:\r\n            if (\r\n                flags[j] == 0\r\n                and get_iou(np.array(obj.box), np.array(objs[j].box)) > iou\r\n            ):\r\n                flags[j] = 1\r\n    return keep\r\n\r\n# Ported from https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/utils.py#L110\r\n# The original code uses torch.Tensor, this uses native numpy arrays\r\ndef detect(\r\n    hm: np.ndarray,           # (H, W, 1), float32\r\n    box: np.ndarray,          # (H, W, 4), float32\r\n    landmark: np.ndarray,     # (H, W, 10), float32\r\n    threshold: float = 0.2,\r\n    nms_iou: float = 0.2,\r\n    stride: int = 8,\r\n) -> list:\r\n    def _sigmoid(x: np.ndarray) -> np.ndarray:\r\n        # stable-ish sigmoid\r\n        out = np.empty_like(x, dtype=np.float32)\r\n        np.negative(x, out=out)\r\n        np.exp(out, out=out)\r\n        out += 1.0\r\n        np.divide(1.0, out, out=out)\r\n        return out\r\n\r\n    def _maxpool3x3_same(x_hw: np.ndarray) -> np.ndarray:\r\n        """\r\n        x_hw: (H, W) single-channel array.\r\n        3x3 max pool, stride=1, padding=1 (same as PyTorch F.max_pool2d(kernel=3,stride=1,padding=1))\r\n        Pure NumPy using stride tricks.\r\n        """\r\n        H, W = x_hw.shape\r\n        # pad with -inf so edges don\'t borrow smaller values\r\n        pad = 1\r\n        xpad = np.pad(x_hw, ((pad, pad), (pad, pad)), mode=\'constant\', constant_values=-np.inf)\r\n\r\n        # build 3x3 sliding windows using as_strided\r\n        s0, s1 = xpad.strides\r\n        shape = (H, W, 3, 3)\r\n        strides = (s0, s1, s0, s1)\r\n        windows = np.lib.stride_tricks.as_strided(xpad, shape=shape, strides=strides, writeable=False)\r\n        # max over the 3x3 window\r\n        return windows.max(axis=(2, 3))\r\n\r\n    def _topk_desc(values_flat: np.ndarray, k: int):\r\n        """Return (topk_values_sorted, topk_indices_sorted_desc)."""\r\n        if k <= 0:\r\n            return np.array([], dtype=values_flat.dtype), np.array([], dtype=np.int64)\r\n        k = min(k, values_flat.size)\r\n        # argpartition for top-k by value\r\n        idx_part = np.argpartition(-values_flat, k - 1)[:k]\r\n        # sort those k by value desc\r\n        order = np.argsort(-values_flat[idx_part])\r\n        idx_sorted = idx_part[order]\r\n        return values_flat[idx_sorted], idx_sorted\r\n\r\n    # 1) sigmoid heatmap\r\n    hm = _sigmoid(hm.astype(np.float32, copy=False))\r\n\r\n    # squeeze channel -> (H, W)\r\n    hm_hw = hm[..., 0]\r\n\r\n    # 2) 3x3 max-pool same\r\n    hm_pool = _maxpool3x3_same(hm_hw)\r\n\r\n    # 3) local maxima mask (keep equal to pooled)\r\n    # (like (hm == hm_pool).float() * hm in torch)\r\n    keep = (hm_hw >= hm_pool)  # >= to keep plateaus, mirrors torch equality on floats closely enough\r\n    candidate_scores = np.where(keep, hm_hw, 0.0).ravel()\r\n\r\n    # 4) topk up to 2000\r\n    num_candidates = int(keep.sum())\r\n    k = min(num_candidates, 2000)\r\n    scores_k, flat_idx_k = _topk_desc(candidate_scores, k)\r\n\r\n    H, W = hm_hw.shape\r\n    ys = (flat_idx_k // W).astype(np.int32)\r\n    xs = (flat_idx_k %  W).astype(np.int32)\r\n\r\n    # 5) gather boxes/landmarks and build outputs\r\n    objs = []\r\n    for cx, cy, score in zip(xs, ys, scores_k):\r\n        if score < threshold:\r\n            # because scores_k is sorted desc, we can break\r\n            break\r\n\r\n        # box offsets at (cy, cx): [x, y, r, b]\r\n        x, y, r, b = box[cy, cx].astype(np.float32, copy=False)\r\n\r\n        # convert to absolute xyrb in pixels (same math as torch code)\r\n        cxcycxcy = np.array([cx, cy, cx, cy], dtype=np.float32)\r\n        xyrb = (cxcycxcy + np.array([-x, -y,  r,  b], dtype=np.float32)) * float(stride)\r\n        xyrb = xyrb.astype(np.int32, copy=False).tolist()\r\n\r\n        # landmarks: first 5 x, next 5 y\r\n        x5y5 = landmark[cy, cx].astype(np.float32, copy=False)\r\n        x5y5 = x5y5 + np.array([cx]*5 + [cy]*5, dtype=np.float32)\r\n        x5y5 *= float(stride)\r\n        box_landmark = list(zip(x5y5[:5].tolist(), x5y5[5:].tolist()))\r\n\r\n        objs.append(BBox("0", xyrb=xyrb, score=float(score), landmark=box_landmark))\r\n\r\n    if nms_iou != -1:\r\n        return nms(objs, iou=nms_iou)\r\n    return objs\r\n\r\n# Detection code from https://github.com/quic/ai-hub-models/blob/8cdeb11df6cc835b9b0b0cf9b602c7aa83ebfaf8/qai_hub_models/models/face_det_lite/app.py#L77\r\ndets = detect(hm, box, landmark, threshold=0.55, nms_iou=-1, stride=8)\r\nres = []\r\nfor n in range(0, len(dets)):\r\n    xmin, ymin, w, h = dets[n].xywh\r\n    score = dets[n].score\r\n\r\n    L = int(xmin)\r\n    R = int(xmin + w)\r\n    T = int(ymin)\r\n    B = int(ymin + h)\r\n    W = int(w)\r\n    H = int(h)\r\n\r\n    if L < 0 or T < 0 or R >= 640 or B >= 480:\r\n        if L < 0:\r\n            L = 0\r\n        if T < 0:\r\n            T = 0\r\n        if R >= 640:\r\n            R = 640 - 1\r\n        if B >= 480:\r\n            B = 480 - 1\r\n\r\n    # Enlarge bounding box to cover more face area\r\n    b_Left = L - int(W * 0.05)\r\n    b_Top = T - int(H * 0.05)\r\n    b_Width = int(W * 1.1)\r\n    b_Height = int(H * 1.1)\r\n\r\n    if (\r\n        b_Left >= 0\r\n        and b_Top >= 0\r\n        and b_Width - 1 + b_Left < 640\r\n        and b_Height - 1 + b_Top < 480\r\n    ):\r\n        L = b_Left\r\n        T = b_Top\r\n        W = b_Width\r\n        H = b_Height\r\n        R = W - 1 + L\r\n        B = H - 1 + T\r\n\r\n    print(f\'Found face: x={L}, y={T}, w={W}, h={H}, score={score}\')\r\n\r\n    res.append([L, T, W, H, score])\r\n\r\n# === END POSTPROCESSING ===\r\n\r\n# Create new PIL image from the input data, stripping off the batch dim\r\ninput_reshaped = input_data.reshape(input_data.shape[1:])\r\nif input_reshaped.shape[2] == 1:\r\n    input_reshaped = np.squeeze(input_reshaped, axis=-1) # strip off the last dim if grayscale\r\n\r\n# And write to output image so we can debug\r\nimg_out = Image.fromarray(input_reshaped).convert("RGB")\r\ndraw = ImageDraw.Draw(img_out)\r\nfor bb in res:\r\n    L, T, W, H, score = bb\r\n    draw.rectangle([L, T, L + w, T + H], outline="#00FF00", width=3)\r\nimg_out.save(IMAGE_OUT)\r\n\r\nprint(\'\')\r\nprint(f\'Inference took (on average): {(end - start) / 10}ms. per image\')\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Run the model on the CPU:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"python3 face_detection.py\r\n\r\n# INFO: Created TensorFlow Lite XNNPACK delegate for CPU.\r\n# Found face: x=120, y=186, w=62, h=79, score=0.8306506276130676\r\n# Found face: x=311, y=125, w=66, h=81, score=0.8148472309112549\r\n# Found face: x=424, y=173, w=64, h=86, score=0.8093323111534119\r\n#\r\n# Inference took (on average): 35.6ms. per image\n"})}),"\n",(0,o.jsx)(n.p,{children:"This already brings down our time per inference from 189.7ms to 35.6ms."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Run the model on the NPU:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"python3 face_detection.py --use-qnn\r\n\r\n# INFO: TfLiteQnnDelegate delegate: 1382 nodes delegated out of 1633 nodes with 27 partitions.\r\n#\r\n# Found face: x=120, y=186, w=62, h=78, score=0.8255056142807007\r\n# Found face: x=311, y=125, w=66, h=81, score=0.8148472309112549\r\n# Found face: x=421, y=173, w=67, h=86, score=0.8093323111534119\r\n#\r\n# Inference took (on average): 2.4ms. per image\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["\ud83c\udf89 That's it. By quantizing this model and porting it to the NPU we've sped the model up 79 times (!). Hopefully you have a good idea of the qualities of AI Hub, and the potential power of the NPU and the AI Engine Direct SDK. You're not limited to Python either, f.e. the ",(0,o.jsx)(n.a,{href:"https://qc-ai-test.gitbook.io/qc-ai-test-docs/running-building-ai-models/lite-rt",children:"LiteRT"})," page has C++ examples as well."]}),"\n",(0,o.jsx)(n.h2,{id:"deploying-a-model-to-npu-edge-impulse",children:"Deploying a model to NPU (Edge Impulse)"}),"\n",(0,o.jsx)(n.p,{children:"Image classification, visual regression, and certain object detection models can be deployed through Edge Impulse."})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var t=r(96540);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);